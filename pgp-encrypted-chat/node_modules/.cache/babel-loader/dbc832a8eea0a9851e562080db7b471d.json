{"ast":null,"code":"import * as openpgp from 'openpgp';\n\n/**\n * Generates a PGP key pair based on user info and passphrase\n */\nexport const generateKeyPair = async (name, email, passphrase) => {\n  try {\n    const {\n      privateKey,\n      publicKey\n    } = await openpgp.generateKey({\n      type: 'rsa',\n      rsaBits: 2048,\n      userIDs: [{\n        name,\n        email\n      }],\n      passphrase\n    });\n    return {\n      privateKey,\n      publicKey,\n      success: true\n    };\n  } catch (error) {\n    console.error('Error generating key pair:', error);\n    return {\n      error: error.message,\n      success: false\n    };\n  }\n};\n\n/**\n * Encrypts a message for a recipient using their public key\n */\nexport const encryptMessage = async (message, publicKeyArmored, sign = false, privateKeyArmored = null, passphrase = '') => {\n  try {\n    const publicKey = await openpgp.readKey({\n      armoredKey: publicKeyArmored\n    });\n    let options = {\n      message: await openpgp.createMessage({\n        text: message\n      }),\n      encryptionKeys: publicKey\n    };\n\n    // Add signing if requested\n    if (sign && privateKeyArmored) {\n      const privateKey = await openpgp.decryptKey({\n        privateKey: await openpgp.readPrivateKey({\n          armoredKey: privateKeyArmored\n        }),\n        passphrase\n      });\n      options.signingKeys = privateKey;\n    }\n    const encrypted = await openpgp.encrypt(options);\n    return {\n      encryptedMessage: encrypted,\n      success: true\n    };\n  } catch (error) {\n    console.error('Error encrypting message:', error);\n    return {\n      error: error.message,\n      success: false\n    };\n  }\n};\n\n/**\n * Decrypts a message using private key\n */\nexport const decryptMessage = async (encryptedMessage, privateKeyArmored, passphrase, senderPublicKey = null) => {\n  try {\n    const privateKey = await openpgp.decryptKey({\n      privateKey: await openpgp.readPrivateKey({\n        armoredKey: privateKeyArmored\n      }),\n      passphrase\n    });\n    const message = await openpgp.readMessage({\n      armoredMessage: encryptedMessage\n    });\n    const decryptOptions = {\n      message,\n      decryptionKeys: privateKey\n    };\n\n    // If sender's public key is provided, use it for verification\n    if (senderPublicKey) {\n      decryptOptions.verificationKeys = await openpgp.readKey({\n        armoredKey: senderPublicKey\n      });\n    }\n    const {\n      data,\n      signatures\n    } = await openpgp.decrypt(decryptOptions);\n\n    // Check if message was signed\n    let verified = false;\n    if (signatures.length > 0) {\n      verified = await signatures[0].verified;\n    }\n    return {\n      decryptedMessage: data,\n      verified,\n      success: true\n    };\n  } catch (error) {\n    console.error('Error decrypting message:', error);\n    return {\n      error: error.message,\n      success: false\n    };\n  }\n};\nexport const signMessage = async (message, privateKeyArmored, passphrase) => {\n  const privateKey = await openpgp.readPrivateKey({\n    armoredKey: privateKeyArmored\n  });\n  await privateKey.decrypt(passphrase);\n  const {\n    signature\n  } = await openpgp.sign({\n    message: await openpgp.createMessage({\n      text: message\n    }),\n    signingKeys: privateKey\n  });\n  return signature;\n};\nexport const verifySignature = async (message, signature, publicKeyArmored) => {\n  const publicKey = await openpgp.readKey({\n    armoredKey: publicKeyArmored\n  });\n  const {\n    verified\n  } = await openpgp.verify({\n    message: await openpgp.createMessage({\n      text: message\n    }),\n    signature: await openpgp.readSignature({\n      armoredSignature: signature\n    }),\n    verificationKeys: publicKey\n  });\n  return verified;\n};","map":{"version":3,"names":["openpgp","generateKeyPair","name","email","passphrase","privateKey","publicKey","generateKey","type","rsaBits","userIDs","success","error","console","message","encryptMessage","publicKeyArmored","sign","privateKeyArmored","readKey","armoredKey","options","createMessage","text","encryptionKeys","decryptKey","readPrivateKey","signingKeys","encrypted","encrypt","encryptedMessage","decryptMessage","senderPublicKey","readMessage","armoredMessage","decryptOptions","decryptionKeys","verificationKeys","data","signatures","decrypt","verified","length","decryptedMessage","signMessage","signature","verifySignature","verify","readSignature","armoredSignature"],"sources":["/workspaces/codespaces-blank/pgp-encrypted-chat/src/services/cryptoService.js"],"sourcesContent":["import * as openpgp from 'openpgp';\n\n/**\n * Generates a PGP key pair based on user info and passphrase\n */\nexport const generateKeyPair = async (name, email, passphrase) => {\n  try {\n    const { privateKey, publicKey } = await openpgp.generateKey({\n      type: 'rsa',\n      rsaBits: 2048,\n      userIDs: [{ name, email }],\n      passphrase\n    });\n\n    return {\n      privateKey,\n      publicKey,\n      success: true\n    };\n  } catch (error) {\n    console.error('Error generating key pair:', error);\n    return {\n      error: error.message,\n      success: false\n    };\n  }\n};\n\n/**\n * Encrypts a message for a recipient using their public key\n */\nexport const encryptMessage = async (message, publicKeyArmored, sign = false, privateKeyArmored = null, passphrase = '') => {\n  try {\n    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });\n    \n    let options = {\n      message: await openpgp.createMessage({ text: message }),\n      encryptionKeys: publicKey\n    };\n    \n    // Add signing if requested\n    if (sign && privateKeyArmored) {\n      const privateKey = await openpgp.decryptKey({\n        privateKey: await openpgp.readPrivateKey({ armoredKey: privateKeyArmored }),\n        passphrase\n      });\n      options.signingKeys = privateKey;\n    }\n    \n    const encrypted = await openpgp.encrypt(options);\n    return {\n      encryptedMessage: encrypted,\n      success: true\n    };\n  } catch (error) {\n    console.error('Error encrypting message:', error);\n    return {\n      error: error.message,\n      success: false\n    };\n  }\n};\n\n/**\n * Decrypts a message using private key\n */\nexport const decryptMessage = async (encryptedMessage, privateKeyArmored, passphrase, senderPublicKey = null) => {\n    try {\n      const privateKey = await openpgp.decryptKey({\n        privateKey: await openpgp.readPrivateKey({ armoredKey: privateKeyArmored }),\n        passphrase\n      });\n  \n      const message = await openpgp.readMessage({\n        armoredMessage: encryptedMessage\n      });\n  \n      const decryptOptions = {\n        message,\n        decryptionKeys: privateKey\n      };\n  \n      // If sender's public key is provided, use it for verification\n      if (senderPublicKey) {\n        decryptOptions.verificationKeys = await openpgp.readKey({ armoredKey: senderPublicKey });\n      }\n  \n      const { data, signatures } = await openpgp.decrypt(decryptOptions);\n  \n      // Check if message was signed\n      let verified = false;\n      if (signatures.length > 0) {\n        verified = await signatures[0].verified;\n      }\n  \n      return {\n        decryptedMessage: data,\n        verified,\n        success: true\n      };\n    } catch (error) {\n      console.error('Error decrypting message:', error);\n      return {\n        error: error.message,\n        success: false\n      };\n    }\n  };\n  \nexport const signMessage = async (message, privateKeyArmored, passphrase) => {\n    const privateKey = await openpgp.readPrivateKey({ armoredKey: privateKeyArmored });\n    await privateKey.decrypt(passphrase);\n    const { signature } = await openpgp.sign({\n        message: await openpgp.createMessage({ text: message }),\n        signingKeys: privateKey,\n    });\n    return signature;\n};\n\nexport const verifySignature = async (message, signature, publicKeyArmored) => {\n    const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });\n    const { verified } = await openpgp.verify({\n        message: await openpgp.createMessage({ text: message }),\n        signature: await openpgp.readSignature({ armoredSignature: signature }),\n        verificationKeys: publicKey,\n    });\n    return verified;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}